Параметры запуска: -XX:+UseSerialGC -Xmx4m -Xms4m

#jmap
Запустим программу и посмотрим текущие данные общее количество объектов 41248, которые потребляют 2103376 байт.
Создадим один объект Item, теперь общее количество объектов возросло до 43378, которые потребляют 2101048 байт. Можно отметить, что количество объектов возросло, в то время как потребляемая память уменьшилась. Можем сделать вывод что GC выполняла сборку мусора.
Выведем добавленный объект, общее количество объектов возросло до 43767, которые потребляют 2117464 байт.
Удалим данный объект, теперь общее количество объектов уменьшилось до 44075, которые потребляют 2133952 байт.

Попробуем вызвать OOM у приложения путем добавления большого количества заявок (объектов Item).
Создадим, для начала, 1000 заявок. Заявки создались успешно, ООМ не вызвалось. Количество объектов: 56348, потребляемая память: 2586720 байт.
Сделаем вывод всех заявок, количество объектов: 77789, потребляемая память 3270328 байт.
Удаляем все созданные заявки, количество объектов: 41018, потребляемая память 2089536 байт.

Создадим 10000 заявок. Заявки создались успешно, ООМ не вызвалось. Количество объектов: 106572 потребляемая память: 3908224 байт.
Сделаем вывод всех заявок, количество объектов: 100801, потребляемая память 3527224 байт. Видим, что была сборка мусора между созданием и выводом заявок, так как количество объектов и потребляемая память уменьшились.
Удаляем все созданные заявки, количество объектов: 58646, потребляемая память 2688864 байт.

Создадим 15000 заявок. Вышли за переделы памяти, вызвался ООМ.

#VisualVM
Повторять для данной утилиты процесс добавления, получения и удаления одного объекта не целесообразно.
Создадим 1000 заявок. Заявки успешно создались. ООМ не вызвалось.
Создадим 5000 заявок. Заявки успешно создались. ООМ не вызвалось.
Создадим 10000 заявок. Вышли за переделы памяти, вызвался ООМ.

Можем сдать вывод что около 1 мб памяти приложения потребляет VisualVM, что так же можно заметить по данным из jmap и графику из VisualVM. В первом случае мы при старте потребляемая память была чуть больше 2 мб, во втором же случае около 3 мб.
По графикам из VisualVM можно сказать, что приложение работало на пределе из-за чего можно наблюдать частые сборки мусора. Больше всего ресурсов процессора было затрачено при создании заявок, в то время как получение и удаление заявок слегка видны на графике.
Аналогичная ситуация и с jconsole. После запуска приложения утилита показывала продляемую память выше 3 мб, результаты можно считать аналогичными с VisualVM.
